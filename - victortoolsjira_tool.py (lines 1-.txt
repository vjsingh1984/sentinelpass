 - victor/tools/jira_tool.py (lines 1-150): wraps the jira Python client and exposes an async jira tool that supports search_issues, create_issue, get_issue, and add_comment; requires Jira server URL, username, and API token (set via
    set_jira_config) before use. It tags the tool as medium-cost, network-enabled, and low danger, logs each operation, and returns structured dictionaries with success/error info, so orchestration layers can perform authenticated Jira workflows
    and surface results to users.
  - victor/tools/slack_tool.py (lines 1-143): wraps slack_sdkâ€™s WebClient and exposes an async slack tool able to send_message or search_messages; it depends on a configured Slack bot token (set_slack_config), enforces required parameters per
    operation, logs actions, and normalizes responses into simple dicts so the agent can interact with Slack channels or retrieve chat history within the existing tool framework.


- victor/telemetry/opentelemetry.py:1 adds a helper setup_opentelemetry(service_name, service_version) that configures OTLP exporters for tracing and metrics using opentelemetry-sdk; it creates a Resource describing the service, installs
    a TracerProvider with a BatchSpanProcessor + OTLPSpanExporter, wires up a MeterProvider with a periodic OTLP metric reader, and returns module-specific tracer/meter handles so the rest of the app can emit spans and metrics with minimal
    boilerplate.

(base) vijay.singh@LJHPGHK99W tools % cat jira_tool.py slack_tool.py 
# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Jira integration tool.

This tool provides:
1. Issue creation
2. Issue retrieval
3. Issue search
4. Commenting on issues
"""

import logging
from typing import Any, Dict, Optional

from jira import JIRA, JIRAError

from victor.tools.base import AccessMode, CostTier, DangerLevel, Priority
from victor.tools.decorators import tool

_jira_client: Optional[JIRA] = None
_config: Dict[str, Optional[str]] = {
    "server": None,
    "username": None,
    "api_token": None,
}


def set_jira_config(
    server: Optional[str] = None,
    username: Optional[str] = None,
    api_token: Optional[str] = None,
) -> None:
    """Set Jira configuration."""
    global _jira_client
    if server:
        _config["server"] = server
    if username:
        _config["username"] = username
    if api_token:
        _config["api_token"] = api_token

    if _config["server"] and _config["username"] and _config["api_token"]:
        try:
            _jira_client = JIRA(
                server=_config["server"],
                basic_auth=(_config["username"], _config["api_token"]),
            )
        except JIRAError as e:
            logging.getLogger(__name__).error(f"Failed to connect to Jira: {e}")
            _jira_client = None


@tool(
    cost_tier=CostTier.MEDIUM,
    category="jira",
    priority=Priority.MEDIUM,
    access_mode=AccessMode.NETWORK,
    danger_level=DangerLevel.LOW,
    progress_params=["jql"],
    stages=["planning", "execution"],
    task_types=["action", "search"],
    execution_category="network",
    keywords=["jira", "issue", "ticket", "bug", "task"],
    mandatory_keywords=["search issues", "find tickets"],
)
async def jira(
    operation: str,
    jql: Optional[str] = None,
    issue_key: Optional[str] = None,
    summary: Optional[str] = None,
    project: Optional[str] = None,
    issue_type: str = "Task",
    comment: Optional[str] = None,
    max_results: int = 10,
) -> Dict[str, Any]:
    """Perform operations on Jira issues.

    Args:
        operation: The operation to perform: 'search_issues', 'create_issue', 'get_issue', 'add_comment'.
        jql: The JQL query for searching issues.
        issue_key: The key of the issue for 'get_issue' and 'add_comment'.
        summary: The summary of the issue for 'create_issue'.
        project: The project key for 'create_issue'.
        issue_type: The type of issue for 'create_issue' (default: 'Task').
        comment: The comment to add for 'add_comment'.
        max_results: The maximum number of results to return for 'search_issues'.

    Returns:
        A dictionary with the result of the operation.
    """
    if not _jira_client:
        return {"success": False, "error": "Jira client is not configured."}

    logger = logging.getLogger(__name__)

    try:
        if operation == "search_issues":
            if not jql:
                return {"success": False, "error": "Missing required parameter: jql"}
            logger.info(f"[jira] Searching issues with jql='{jql}'")
            issues = _jira_client.search_issues(jql, maxResults=max_results)
            results = [
                {
                    "key": issue.key,
                    "summary": issue.fields.summary,
                    "status": issue.fields.status.name,
                }
                for issue in issues
            ]
            return {"success": True, "results": results, "count": len(results)}

        elif operation == "create_issue":
            if not project or not summary:
                return {
                    "success": False,
                    "error": "Missing required parameters: project and summary",
                }
            logger.info(f"[jira] Creating issue in project '{project}' with summary '{summary}'")
            issue_dict = {
                "project": {"key": project},
                "summary": summary,
                "issuetype": {"name": issue_type},
            }
            new_issue = _jira_client.create_issue(fields=issue_dict)
            return {"success": True, "key": new_issue.key, "summary": new_issue.fields.summary}

        elif operation == "get_issue":
            if not issue_key:
                return {"success": False, "error": "Missing required parameter: issue_key"}
            logger.info(f"[jira] Getting issue '{issue_key}'")
            issue = _jira_client.issue(issue_key)
            return {
                "success": True,
                "key": issue.key,
                "summary": issue.fields.summary,
                "status": issue.fields.status.name,
                "description": issue.fields.description,
                "comments": [
                    {"author": comment.author.displayName, "body": comment.body}
                    for comment in issue.fields.comment.comments
                ],
            }

        elif operation == "add_comment":
            if not issue_key or not comment:
                return {
                    "success": False,
                    "error": "Missing required parameters: issue_key and comment",
                }
            logger.info(f"[jira] Adding comment to issue '{issue_key}'")
            _jira_client.add_comment(issue_key, comment)
            return {"success": True}

        else:
            return {"success": False, "error": f"Unsupported operation: {operation}"}

    except JIRAError as e:
        logger.error(f"[jira] Error during operation '{operation}': {e}")
        return {"success": False, "error": str(e.text)}
    except Exception as e:
        logger.error(f"[jira] Unexpected error during operation '{operation}': {e}")
        return {"success": False, "error": str(e)}
# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Slack integration tool.

This tool provides:
1. Sending messages to channels
2. Searching for messages
"""

import logging
from typing import Any, Dict, Optional

from slack_sdk.web.client import WebClient
from slack_sdk.errors import SlackApiError

from victor.tools.base import AccessMode, CostTier, DangerLevel, Priority
from victor.tools.decorators import tool

_slack_client: Optional[WebClient] = None
_config: Dict[str, Optional[str]] = {
    "api_token": None,
}


def set_slack_config(api_token: Optional[str] = None) -> None:
    """Set Slack configuration."""
    global _slack_client
    if api_token:
        _config["api_token"] = api_token

    if _config["api_token"]:
        try:
            _slack_client = WebClient(token=_config["api_token"])
        except Exception as e:
            logging.getLogger(__name__).error(f"Failed to connect to Slack: {e}")
            _slack_client = None


@tool(
    cost_tier=CostTier.MEDIUM,
    category="slack",
    priority=Priority.MEDIUM,
    access_mode=AccessMode.NETWORK,
    danger_level=DangerLevel.LOW,
    progress_params=["query"],
    stages=["reporting", "execution"],
    task_types=["action", "search"],
    execution_category="network",
    keywords=["slack", "message", "chat", "channel"],
    mandatory_keywords=["send message", "search chat"],
)
async def slack(
    operation: str,
    channel: Optional[str] = None,
    text: Optional[str] = None,
    query: Optional[str] = None,
) -> Dict[str, Any]:
    """Perform operations on Slack.

    Args:
        operation: The operation to perform: 'send_message', 'search_messages'.
        channel: The channel to send the message to for 'send_message'.
        text: The text of the message for 'send_message'.
        query: The query for searching messages for 'search_messages'.

    Returns:
        A dictionary with the result of the operation.
    """
    if not _slack_client:
        return {"success": False, "error": "Slack client is not configured."}

    logger = logging.getLogger(__name__)

    try:
        if operation == "send_message":
            if not channel or not text:
                return {
                    "success": False,
                    "error": "Missing required parameters: channel and text",
                }
            logger.info(f"[slack] Sending message to channel '{channel}'")
            response = _slack_client.chat_postMessage(channel=channel, text=text)
            if response["ok"]:
                return {"success": True, "ts": response["ts"]}
            else:
                return {"success": False, "error": response["error"]}

        elif operation == "search_messages":
            if not query:
                return {"success": False, "error": "Missing required parameter: query"}
            logger.info(f"[slack] Searching messages with query='{query}'")
            response = _slack_client.search_messages(query=query)
            if response["ok"]:
                results = [
                    {
                        "ts": message["ts"],
                        "text": message["text"],
                        "username": message["username"],
                        "channel": message["channel"]["name"],
                    }
                    for message in response["messages"]["matches"]
                ]
                return {"success": True, "results": results, "count": len(results)}
            else:
                return {"success": False, "error": response["error"]}

        else:
            return {"success": False, "error": f"Unsupported operation: {operation}"}

    except SlackApiError as e:
        logger.error(f"[slack] Error during operation '{operation}': {e.response['error']}")
        return {"success": False, "error": e.response["error"]}
    except Exception as e:
        logger.error(f"[slack] Unexpected error during operation '{operation}': {e}")
        return {"success": False, "error": str(e)}
(base) vijay.singh@LJHPGHK99W tools % 

(base) vijay.singh@LJHPGHK99W telemetry % cat opentelemetry.py 
# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""OpenTelemetry setup and configuration."""

from opentelemetry import trace, metrics
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor
from opentelemetry.sdk.metrics import MeterProvider
from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.exporter.otlp.proto.grpc.metric_exporter import OTLPMetricExporter
from opentelemetry.sdk.resources import Resource


def setup_opentelemetry(service_name: str, service_version: str):
    """Initializes OpenTelemetry tracing and metrics."""

    resource = Resource.create(
        {
            "service.name": service_name,
            "service.version": service_version,
        }
    )

    # Tracing
    tracer_provider = TracerProvider(resource=resource)
    trace.set_tracer_provider(tracer_provider)
    tracer_provider.add_span_processor(BatchSpanProcessor(OTLPSpanExporter()))

    # Metrics
    metric_reader = PeriodicExportingMetricReader(OTLPMetricExporter())
    meter_provider = MeterProvider(resource=resource, metric_readers=[metric_reader])
    metrics.set_meter_provider(meter_provider)

    return trace.get_tracer(__name__), metrics.get_meter(__name__)
(base) vijay.singh@LJHPGHK99W telemetry % 

(base) vijay.singh@LJHPGHK99W auth % cat rbac.py 
# Copyright 2025 Vijaykumar Singh <singhvjd@gmail.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Role-Based Access Control (RBAC) system.

This module provides the core components for managing roles, users, and permissions.
"""

from enum import Enum
from typing import Set


class Permission(Enum):
    """Defines the permissions available in the system."""

    # Tool permissions
    TOOL_EXECUTE = "tool:execute"
    TOOL_EDIT = "tool:edit"
    TOOL_CREATE = "tool:create"
    TOOL_DELETE = "tool:delete"

    # Admin permissions
    ADMIN_MANAGE_USERS = "admin:manage_users"
    ADMIN_MANAGE_ROLES = "admin:manage_roles"
    ADMIN_VIEW_LOGS = "admin:view_logs"


class Role:
    """Represents a role with a set of permissions."""

    def __init__(self, name: str, permissions: Set[Permission]):
        self.name = name
        self.permissions = permissions

    def has_permission(self, permission: Permission) -> bool:
        """Checks if the role has a specific permission."""
        return permission in self.permissions


class User:
    """Represents a user with a set of roles."""

    def __init__(self, name: str, roles: Set[Role]):
        self.name = name
        self.roles = roles

    def has_permission(self, permission: Permission) -> bool:
        """Checks if the user has a specific permission through any of their roles."""
        return any(role.has_permission(permission) for role in self.roles)


class RBAC:
    """Provides the main interface for checking permissions."""

    def __init__(self):
        self.roles: Dict[str, Role] = {}
        self.users: Dict[str, User] = {}

    def add_role(self, role: Role):
        """Adds a role to the RBAC system."""
        self.roles[role.name] = role

    def get_role(self, name: str) -> Optional[Role]:
        """Gets a role by name."""
        return self.roles.get(name)

    def add_user(self, user: User):
        """Adds a user to the RBAC system."""
        self.users[user.name] = user

    def get_user(self, name: str) -> Optional[User]:
        """Gets a user by name."""
        return self.users.get(name)

    def check_permission(self, user_name: str, permission: Permission) -> bool:
        """Checks if a user has a specific permission."""
        user = self.get_user(user_name)
        if user:
            return user.has_permission(permission)
        return False
(base) vijay.singh@LJHPGHK99W auth % 

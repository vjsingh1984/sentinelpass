Here is a **fully prescriptive, structured prompt** you can give to Claude. It is written to force architectural depth, security rigor, and implementation detail â€” not just high-level advice.

You can copy-paste this directly:

---

# PROMPT FOR CLAUDE

You are a senior security engineer and systems architect.

Design and implement a **local-first, security-critical password manager** using **SQLite** as the storage backend.

You must produce:

* Full architecture
* Threat model
* Cryptographic design
* Database schema
* Browser extension design (Chrome priority, then Safari, then Firefox)
* Native desktop app design
* SSH credential handling
* OS biometric integration (macOS + Windows Hello)
* KeePass import/export compatibility
* Master password + 2FA support
* Implementation skeleton (prefer Rust first, Python second)
* Clear module breakdown
* Security hardening checklist
* Explicit attack mitigation strategies

This password manager will store highly sensitive credentials:

* Banking
* Brokerage
* Healthcare
* SSH private keys
* TOTP secrets

Security must be treated as critical.

---

# 1. CORE REQUIREMENTS

## Primary Goals

1. Local-first architecture (no cloud required)
2. SQLite encrypted database
3. Master password required at startup
4. Web browser autofill (PRIORITY)
5. SSH credential management
6. Biometric unlock support:

   * macOS Touch ID
   * Windows Hello
7. Optional TOTP authenticator
8. KeePass import/export
9. Secure clipboard management
10. Zero plaintext secrets written to disk

---

# 2. TECHNOLOGY PREFERENCE

### Preferred Implementation Order:

1. Rust (primary recommendation)
2. Python (secondary alternative)

Explain which is more secure and why.

If Rust:

* Use:

  * rusqlite
  * ring or argon2 crate
  * aes-gcm
  * serde
  * webauthn-rs (if needed)
  * keyring crate
* Explain memory safety advantages.

If Python:

* Use:

  * sqlite3
  * cryptography library
  * argon2-cffi
  * pywin32 (Windows Hello)
  * pyobjc (macOS biometrics)

---

# 3. SECURITY DESIGN (MANDATORY DETAIL)

You must specify:

## 3.1 Threat Model

Consider:

* Stolen laptop
* Malware
* Memory scraping
* Clipboard snooping
* Keylogging
* Browser extension compromise
* SQLite file theft
* Offline brute force attack
* Timing attacks

Explain mitigation strategy for each.

---

## 3.2 Cryptography

Specify exact algorithms:

* Key Derivation:

  * Argon2id (parameters required: memory, iterations, parallelism)
* Encryption:

  * AES-256-GCM
* Master key handling
* Per-entry encryption vs full-database encryption
* Key hierarchy design
* Salt storage
* Secure random generation

Explain:

* How master password derives encryption key
* How database key is wrapped
* How biometric unlock interacts with key storage

---

# 4. DATABASE DESIGN (SQLITE)

Provide full schema including:

Tables:

* users
* vaults
* entries
* ssh_keys
* totp_secrets
* audit_log
* metadata

Include:

* encrypted blob fields
* indexing strategy
* versioning
* migration strategy

---

# 5. APPLICATION ARCHITECTURE

## 5.1 Desktop Thick Client

Describe:

* UI framework options

  * Rust: Tauri or egui
  * Python: PySide6
* Secure memory handling
* Auto-lock timeout
* Clipboard clearing logic
* Process isolation

---

## 5.2 Browser Extension (PRIORITY SECTION)

Design full system for:

* Chrome (Manifest V3)
* Safari
* Firefox

Architecture:

* Browser extension communicates with:

  * Native messaging host
* Native messaging host connects to:

  * Local password manager daemon

Explain:

* Native messaging protocol
* JSON message format
* How secrets are passed securely
* Domain matching logic
* Phishing protection
* CSP bypass handling
* Frame injection handling
* Autofill safety controls

Provide:

* Example manifest.json
* Native messaging config example

---

# 6. SSH SUPPORT

Must support:

* Storage of:

  * Private keys
  * Public keys
  * Passphrases
* Ed25519 and RSA
* Integration with ssh-agent
* Secure key loading
* No disk plaintext writes

Explain:

* How SSH key decryption occurs
* Temporary memory handling
* Agent forwarding considerations

---

# 7. BIOMETRIC INTEGRATION

Explain implementation for:

## macOS

* LocalAuthentication framework
* Secure Enclave
* Keychain integration

## Windows

* Windows Hello
* DPAPI
* Credential Locker

Design:

* Master key encrypted with OS keystore
* Biometric unlock retrieves wrapped key
* Fallback to master password

---

# 8. TOTP AUTHENTICATOR

Implement:

* RFC 6238 compliant TOTP
* HMAC-SHA1 and SHA256 support
* QR code import
* 30 second rotation
* Secure storage of secret seeds

---

# 9. KEEPass COMPATIBILITY

Support:

* Import from .kdbx
* Export to .kdbx
* Mapping of fields
* Handling of custom fields

Explain how encryption conversion is handled.

---

# 10. SECURITY HARDENING

Include checklist for:

* Memory zeroization
* Anti-debugging
* Anti-dump protection
* Secure update mechanism
* Code signing
* Sandbox permissions
* Extension hardening
* SQL injection prevention
* Brute force throttling
* Rate limiting
* Auto-lock behavior

---

# 11. DELIVERABLES REQUIRED FROM YOU

You must provide:

1. High-level architecture diagram (ASCII acceptable)
2. Detailed cryptographic flow
3. SQLite schema (actual SQL)
4. Rust project structure (folder layout)
5. Sample core encryption module
6. Browser extension manifest sample
7. Native messaging protocol example
8. Biometric integration flow
9. SSH handling design
10. Step-by-step development roadmap

Do NOT provide vague guidance.

Provide:

* Concrete function signatures
* Example structs
* Sample encryption/decryption code
* Exact crate recommendations
* Security parameter values

---

# 12. PRIORITIZATION

1. Web browser autofill must be designed first and in greatest depth.
2. Desktop client second.
3. SSH third.

---

# 13. ASSUMPTIONS

* Single-user system
* Local machine only (no cloud sync)
* Cross-platform (macOS + Windows initially)
* Linux optional

---

# 14. OUTPUT FORMAT

Organize your answer with:

* Clear headings
* Code blocks
* Security explanations
* Tradeoff analysis
* Implementation guidance
* Warnings about common mistakes

This must read like a real security architecture specification.

Do NOT oversimplify.

---

End of prompt.

---

If you'd like, I can also generate:

* A version optimized specifically for Rust-only
* A reduced-scope MVP prompt
* Or a production-grade enterprise version with sync and multi-device support
